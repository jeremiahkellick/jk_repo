<!DOCTYPE html>
<html>
    <head>
        <title>Jeremiah Kellick</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>

@font-face {
    font-family: "Noto Serif";
    src: url("/jk_assets/website/NotoSerif-Regular.ttf") format("truetype");
}

@font-face {
    font-family: "Noto Serif";
    font-style: italic;
    src: url("/jk_assets/website/NotoSerif-Italic.ttf") format("truetype");
}

body {
    background: #162027;
    color: #d0dbe2;
    font-family: "Noto Serif", sans-serif;
    font-size: 22px;
    line-height: 1.8;
    margin: 0;
}

h1 {
    margin: 0;
    font-weight: normal;
}

#tagline {
    margin: 0;
}

p {
    margin: 25px 0 0 0;
}

a {
    color: #7799ff;
    position: relative;
    text-decoration: underline;
    text-decoration-thickness: 1px;
    text-underline-offset: 8px;
    z-index: 10;
}

a:visited {
    color: #b693fb;
}

blockquote {
    border-left: 4px solid #d0dbe2;
    margin: 0;
    padding-left: 40px;
    padding-bottom: 25px;
}

#content {
    margin: 64px auto;
    padding: 0 32px;
    max-width: 750px;
}

#profile-picture {
    display: block;
    border-radius: 100%;
    margin: auto;
    width: 220px;
}

@media (min-width: 730px) {
    #profile-picture {
        float: left;
        margin: 28px 28px 0 0;
    }
}

#chess {
    aspect-ratio: 1;
    box-sizing: context-box;
    display: block;
    margin: 25px -12.5% 0 -12.5%;
    width: 125%;
}

        </style>
    </head>
    <body>
        <div id="content">
            <img id="profile-picture" src="/jk_assets/website/profile-picture.jpg" />
            <h1>Hi! I'm Jeremiah</h1>
            <p id="tagline">a web developer turned systems programmer.</p>
            <p>
                I'm looking for work. If you're in a hurry, see
                <a href="/TODO/RESUME">my resume.</a> If you'd like a lengthy account of what I'm
                all about, read on!
            </p>
            <p>
                Currently my biggest "claim to fame" is that I landed a software development job at
                Google when I was nineteen. Programming interested me early-on because I loved to
                make games. By the time I graduated high school, I was already a decent programmer.
                Looking for a faster way to enter the industry, I attended a coding bootcamp, App
                Academy, instead of going to college. I was lucky enough to get a job at Google
                afterwards.
            </p>
            <p>
                I worked at Google's Pittsburgh office for four years, making UIs for their Cloud
                Console to accompany several Vertex AI product lauches. I had fun, met some
                incredible people, and learned about working within and across teams. It was a dream
                job for me, but after a while I felt like staying there would be bad for my
                long-term development as a programmer.
            </p>
            <p>
                I used to not see much value in low-level programming knowledge beyond satifying
                one's curiosity. I saw myself as pragmatic: I'll take shortest path to my end goal.
                I saw myself as humble: the authors of popular libraries and frameworks are probably
                better programmers than me. If I can produce a higher quality product faster by
                leveraging code I don't fully understand, it would be foolish not to. I still feel
                that way, but I've come to realize what an awfully big <em>if</em> that is.
            </p>
            <p>
                There are some large factors missing from the above thought process.
            </p>
            <ol>
                <li>
                    Popularity is a poor heuristic for quality. In order to do better than that
                    heuristic when evaluating a library yourself, you need at least a rough
                    understanding of its internals.
                </li>
                <li>
                    Libraries and frameworks are written for a wide range of use cases. Therefore,
                    they'll never be perfect for your specific case. If you solve the problem
                    yourself, you can fine-tune the solution to fit your needs.
                </li>
                <li>
                    Because you probably only need a subset of a library's functionality, it might
                    not be as large an undertaking as you think to do it yourself.
                </li>
            </ol>
            <p>
                The projects I worked on at Google had poor compilation speed and poor runtime
                performance. The painfully slow edit-compile-run cycle hurt my productivity and
                drained much of the joy out of programming. No back-of-the-envelope math can really
                make sense of the numbers. The performance of our product couldn't be remotely
                justified by what data we needed to deliver to the user or by what their CPU needed
                to do to produce our desired result.
            </p>
            <p>
                It's just wasted bandwidth and CPU cycles which stem from the common view that
                performance is something you should only think about after it gets unbearably bad.
                There's this widespread attitude that you should address performance retroactively,
                never proactively. The quote "premature optimization is the root of all evil" is
                often misused to justify never planning ahead with regard to the performance of
                one's software. The expanded Donald Knuth quote tells a different story (emphasis
                mine).
            </p>
            <blockquote>
                <p>
                    We should forget about <strong>small efficiencies</strong>, say about 97% of the
                    time: premature optimization is the root of all evil.
                </p>
                <p>
                    Yet we <strong>should not pass up our opportunities in that critical
                    3%.</strong>
                </p>
            </blockquote>
            <p>
                Small efficiencies! Knuth never meant for the quote to apply to large-scale,
                difficult-to-reverse decisions like application architecture or the introduction of
                a major dependency.
            </p>
            <p>
                My bad experiences with a bloated codebase sprouted my interest in systems
                programming and working at a smaller company. I like to have some contact with the
                ground truth of what's happening on the CPU. I want there to be some resonable
                relationship between what back-of-the-envelope math says about how fast my code
                could run and how fast it actually does run. I'm certainly not aiming for optimal in
                all cases, but I never want to see a 1,000x difference between those numbers.
            </p>
            <p>
                I'd love to work either at a company that alreadly aligns somewhat with these views
                on what good software development looks like or a company small enough where I can
                make many of those decisions for myself. If you're hiring and resonant with anything
                I'm saying here, please <a href="/TODO">reach out!</a>
            </p>
            <p>
                With that goal in mind, I left my job at Google and took some time off to educate
                myself on systems programming. Recall that I didn't go to college, so I definitely
                had some studying to do. This educational arc culminated in my most recent portfolio
                project, a chess application written from scratch in C. It supports three platforms:
                Windows, macOS, and the web. You can check out the web version here on this page or
                download native executables on the
                <a href="https://github.com/jeremiahkellick/jk_repo/releases">GitHub Releases</a>
                page. I'll talk about some technical details and more of the ways I've educated
                myself below, but first, try it out!
            </p>
            <canvas id="chess"></canvas>
            <p>
                Okay, hope you think that's neat. I had fun making it! Now let's go behind the
                scenes.
            </p>
            <p>
                Please note that my attitude towards dependencies for educational projects is
                different from what it is for real products. I do think the average programmer today
                is far too cavalier with their dependency usage, but of course it's possible to
                overcorrect. I made decisions during this project that would've been bad choices had
                I been optimizing for customer value. Going into <em>extreme</em> "not invented
                here" territory is an excellent learning exercise, but not always best for
                customers. For that, I would merely prescribe <em>moderate</em> "not invented here"
                syndrome.
            </p>
            <p>
                With that disclaimer out of the way, let's talk about the chess app's dependencies.
                I use stb_truetype in my build toolchain, but not the program itself (more on this
                later). The Windows and macOS versions depend on only the C standard library and
                APIs provided by their respective operating systems. The web version doesn't even
                use the C standard library because that's not available to WebAssembly by default.
                That means none of the platform-independent code can use the standard library, which
                took me down a couple fun rabbit holes.
            </p>
            <p>
                For floating-point rounding and square root I was able to rely on x86 intrinsics
                when using MSVC and builtins when using Clang or GCC, but replacing sine and
                arccosine was more interesting. I used Mathematica to compute constants for
                <a href="https://github.com/jeremiahkellick/jk_repo/blob/v0.1/jk_src/jk_lib/jk_lib.c#L544">
                polynomial approximations of those functions.</a>
            </p>
            <p>
                I also wrote a printf replacement. The most interesting part was the
                <a href="https://github.com/jeremiahkellick/jk_repo/blob/v0.1/jk_src/jk_lib/jk_lib.c#L326">
                function that converts a floating-point number to a string,</a> accurate to about
                eight decimal places.
            </p>
            <p>
                What's the deal with stb_truetype? At one point in development I was using scaled
                bitmaps to render the game, but it was slow and extrememly memory inefficient. I
                wanted a resolution-independent way to render my chess pieces and text. The
                stb_truetype library was alluring, but up until that point I had the deep
                satisfaction of understanding nearly everything my program was doing. Being so
                close to writing the full program that way, I was loath to let this one feature ruin
                it.
            </p>
            <p>
                I noticed that stb_truetype is only 5,000 lines of code, and I knew most of that was
                probably dealing with the intricacies of the truetype file format. The rasterization
                code can't be too complicated!
            </p>
            <p>
                I settled on a compromise: I would try to write a vector graphics rasterizer that
                uses my own data format. For text, I would use stb_truetype in my build process
                to extract data from the font file and convert it to my format. For the chess
                pieces, I would parse a subset of the SVG path format.
            </p>
            <p>
                It was a success! The chess executable doesn't contain any stb_truetype code. The
                font and chess pieces are built into the executable in a
                <a href="https://github.com/jeremiahkellick/jk_repo/blob/v0.1/jk_src/jk_shapes/jk_shapes.h#L58">
                simple vector format</a> and rendered with the
                <a href="https://github.com/jeremiahkellick/jk_repo/blob/v0.1/jk_src/jk_shapes/jk_shapes.c#L514">
                rasterizer I wrote.</a> Still, much credit to Sean Barrett, the author of the stb
                libraries. His <a href="https://nothings.org/gamedev/rasterize/">writeup on how the
                stb_truetype anti-aliasing works</a> is the reason I was able to understand the
                rasterization process well enough to write it myself.
            </p>
            <p>
                The other most interesting part of the project is the AI. As a challenge to myself,
                I did not read up on how to write a chess bot. I wanted to see how far I could get
                "on my own steam." I'm reasonably happy with the result. It's better than I am at
                chess, though I can still eke out a win against it occasionally.
            </p>
            <p>
                Now that I've made the AI about as good as I can on my own, I'm looking forward to
                finally reading up on the state-of-the-art techniques and implementing some of those
                to see if I can write an AI that I will never checkmate.
            </p>
            <p>
                Okay, that covers the chess app, but what else have I been up to in these
                education-focused years? I read the classic <em>C Programming Language</em> by Brian
                Kernighan and Dennis Ritchie. I attended Carnegie Mellon as a non-degree student,
                taking three courses:
            </p>
            <ul>
                <li>18-213 Introduction to Computer Systems</li>
                <li>15-411 Compiler Design</li>
                <li>15-410 Operating System Design and Implementation</li>
            </ul>
            <p>
                90%+ of the workload for all of those courses was large programming projects. I
                can't post the code publicly, but I can share it privately if you'd like to see code
                from me that interacts more closely with hardware than my chess app does.
            </p>
            <p>
                I took Casey Muratori's Substack course,
                <a href="https://www.computerenhance.com/p/table-of-contents">Performance-Aware
                Programming.</a> It's ongoing, but I've watched and
                <a href="https://github.com/jeremiahkellick/jk_repo/tree/master/jk_src/perfaware">
                done the homework</a> for all the episodes that have been release at time of writing
                (2025-09-15).
            </p>
            <p>
                I self-studied math. I read and did odd-numbered exercises in <em>Mathematical
                Proofs: A Transition to Advanced Mathematics</em> by Gary Chartrand, Albert D.
                Polimeni, and Ping Zhang. I'm currently working through <em>Linear Algebra Done
                Right</em> by Sheldon Axler. If it interests you, check out my
                <a href="/jk_assets/website/jkellick_ladr_exercises.pdf">exercise solutions</a> for
                the first three chapters.
            </p>
            <p>I also put ~400 hours into learning Chinese.</p>
            <p>
                Whew, that's enough talking about myself. Thanks for reading! If you're interested
                in hiring me, or if you'd like to contact me for any other reason, email
                jeremiah@jeremiahkellick.com.
            </p>
            <script src="/jk_src/chess/chess.js"></script>
        </div>
    </body>
</html>
