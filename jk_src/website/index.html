<!DOCTYPE html>
<html>
    <head>
        <title>Jeremiah Kellick</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>

@font-face {
    font-family: "Noto Serif";
    src: url("/jk_assets/website/NotoSerif-Regular.ttf") format("truetype");
}

@font-face {
    font-family: "Noto Serif";
    font-style: italic;
    src: url("/jk_assets/website/NotoSerif-Italic.ttf") format("truetype");
}

body {
    background: #162027;
    color: #d0dbe2;
    font-family: "Noto Serif", sans-serif;
    font-size: 22px;
    line-height: 1.8;
    margin: 0;
}

h1 {
    margin: 0;
    font-weight: normal;
}

#tagline {
    margin: 0;
}

p {
    margin: 25px 0 0 0;
}

a {
    color: #7799ff;
    position: relative;
    text-decoration: underline;
    text-decoration-thickness: 1px;
    text-underline-offset: 8px;
    z-index: 10;
}

a:visited {
    color: #b693fb;
}

blockquote {
    border-left: 4px solid #d0dbe2;
    margin: 0;
    padding-left: 40px;
    padding-bottom: 25px;
}

#content {
    margin: 64px auto;
    padding: 0 32px;
    max-width: 750px;
}

#profile-picture {
    display: block;
    border-radius: 100%;
    margin: auto;
    width: 220px;
}

@media (min-width: 730px) {
    #profile-picture {
        float: left;
        margin: 28px 28px 28px 0;
    }
}

#chess {
    aspect-ratio: 1;
    box-sizing: context-box;
    display: block;
    margin: 25px -12.5% 0 -12.5%;
    width: 125%;
}

        </style>
    </head>
    <body>
        <div id="content">
            <img id="profile-picture" src="/jk_assets/website/profile-picture.jpg" />
            <h1>Hi! I'm Jeremiah</h1>
            <p id="tagline">a web developer turned systems programmer</p>
            <p>
                I'm looking for work. In a hurry? See <a href="/TODO/RESUME">my&nbsp;resume.</a>
                Want my full story? Read on.
            </p>
            <p>
                When I was nineteen, Google hired me to program full-time. I got into programming
                early because I loved video games and wanted to make them. It so captivated me that
                by my high-school graduation, I wanted to do it full-time. So instead of college, I
                took a chance on a faster path. I attended a coding bootcamp called App Academy.
                They filled gaps in my knowledge and prepared me for technical interviews. Then came
                months of job searching. I won't forget the tension answering the recruiter's phone
                call after my Google interviews. To my delight, they made an offer.
            </p>
            <p>
                For the next four years, I worked at Google Pittsburgh making UIs for Vertex AI
                products. I had fun, met incredible people, and learned to work within and across
                teams. It was my dream job. But eventually, I would dream bigger.
            </p>
            <p>
                Before, I didn't see much point in low-level systems knowledge except for
                curiosity's sake. I thought myself pragmatic—I'll take the shortest path to my goal.
                I thought myself humble—the authors of popular libraries and frameworks are better
                than me. If I can get better results faster using code I don't fully understand, I'd
                be foolish not to. Now I realize, that's an awfully big <em>if.</em>
            </p>
            <p>
                One day I saw a talk on YouTube,
                <a href="https://www.youtube.com/watch?v=De0Am_QcZiQ">"Making Game Programming Less
                Terrible" by Jonathan Blow.</a> He criticized the "New Document" menu in Photoshop
                taking one second to load. Was this really noteworthy? You probably encounter things
                like this on a daily basis. There were many examples in the product I worked on.
            </p>
            <p>
                "Imagine if the people who programmed this were trying to make VR games. Like,
                everybody would be vomiting everywhere all the time." Jon Blow joked. That computer
                could render a pretty 3D environment from two different perspectives in eleven
                milliseconds. Why then did it take a thousand to display Photoshop's "New Document"
                menu?
            </p>
            <p>
                I thought "It's market-driven." Programmer time is expensive, and it probably takes
                more to achieve high performance. Should the company pay for that? You would refund
                a VR game that made you vomit. In Photoshop's case, however, few customers will
                unsubscribe when the "New Document" menu takes a second to load. It feels bad, but
                it might just be good economics to prioritize other things.
                <a id="footnote-1-link" href="#footnote-1">[1]</a>
            </p>
            <p>
                My opinion changed when Jon compiled his game in less than a second. This was
                impressive at the time, but to drive the point in further, jump forward to May 2025
                when his game was 300k lines of code and
                <a href="https://youtu.be/RIYGaSBKy3w?t=646">compiled in 2.3 seconds.</a>
                In <a href="https://youtu.be/jamU6SQBtxk?t=5172">an interview</a> Jon said "It's
                big. So far I think it's a reasonable estimation that if someone wants to 100% the
                game, if they're an average person, it's probably over 500 hours of play time."
            </p>
            <p>
                That demonstration convinced me software development could be far better than I
                knew. The market dynamics argument plays out differently when it comes to
                compilation speed. Try to save your programmers' time using shortcuts that slow down
                compilation, and it backfires because slow compilation consumes the resource you
                were supposedly trying to save. So why did it take 30 minutes to start my project's
                development server? Why did it take 5 minutes to compile the unit tests for a single
                UI component? Jon's game was staggeringly more complex than that UI component. He
                compiled on a single computer. I used a server farm.
            </p>
            <p>
                The talk inspired me to learn systems programming so I could write software with
                better compilation and runtime performance. I read the classic
                <em>C Programming Language</em> by Brian Kernighan and Dennis Ritchie. I took some
                courses from Carnegie Mellon as a non-degree student on the side:
            </p>
            <ul>
                <li>18-213 Introduction to Computer Systems</li>
                <li>15-411 Compiler Design</li>
            </ul>
            <p>
                Compiler Design was difficult to balance with my job. I had no time for friends or
                family, so after that I left my job at Google to focus full-time on education. I
                took a third course from Carnegie:
            </p>
            <ul>
                <li>15-410 Operating System Design and Implementation</li>
            </ul>
            <p>
                90%+ of the workload for those courses was large programming projects. I can't post
                the code publicly, but I can share it privately.
            </p>
            <p>
                Then I took Casey Muratori's Substack course,
                <a href="https://www.computerenhance.com/p/table-of-contents">Performance-Aware
                Programming.</a> It's ongoing, but I've watched and
                <a href="https://github.com/jeremiahkellick/jk_repo/tree/master/jk_src/perfaware">
                done the homework</a> for all the episodes that have been release at time of writing
                (2025-09-26).
            </p>
            <p>
                Next, I wanted a project to show publicly that demonstrates systems programming
                knowledge, so I wrote a chess application from scratch in C. It supports three
                platforms: Windows, macOS, and the web. You can try the web version right here on
                this page or download native executables on the
                <a href="https://github.com/jeremiahkellick/jk_repo/releases">GitHub Releases</a>
                page. I'll discuss the technical details below. But first, try it out!
            </p>
            <canvas id="chess"></canvas>
            <p>
                Okay, I hope you think that's neat. I had fun making it! Now let's go behind the
                scenes.
            </p>
            <p>
                At runtime, the Windows and macOS ports depend on only the C standard library and
                APIs provided by their respective operating systems. The web version doesn't even
                use the C standard library, so none of the platform-independent code can use it
                either, which took me down a couple fun rabbit holes.
            </p>
            <p>
                For floating-point rounding and square root I was able to rely on x86 intrinsics
                when using MSVC and builtins when using Clang or GCC, but replacing sine and
                arccosine was more interesting. I used Mathematica to compute constants for
                <a href="https://github.com/jeremiahkellick/jk_repo/blob/v0.1/jk_src/jk_lib/jk_lib.c#L544">
                polynomial approximations of those functions.</a>
            </p>
            <p>
                I also wrote a printf replacement. The most interesting part was the
                <a href="https://github.com/jeremiahkellick/jk_repo/blob/v0.1/jk_src/jk_lib/jk_lib.c#L326">
                function that converts a floating-point number to a string,</a> accurate to about
                eight decimal places.
            </p>
            <p>
                The app is resolution-independent. I wrote a
                <a href="https://github.com/jeremiahkellick/jk_repo/blob/v0.1/jk_src/jk_shapes/jk_shapes.c#L514">
                vector graphics rasterizer</a> to draw the chess pieces and text. For the chess
                pieces, I
                <a href="https://github.com/jeremiahkellick/jk_repo/blob/v0.1/jk_src/chess/chess_assets_pack.c#L73">
                parse</a> a
                <a href="https://github.com/jeremiahkellick/jk_repo/blob/v0.1/jk_assets/chess/paths.txt">
                subset of the SVG path format.</a> For the text, I use stb_truetype to to extract
                data from a font file and convert it to the format my rasterizer understands, but I
                just do that in a separate program that runs as a build step. The executable does
                not contain any stb_truetype code, only my custom rasterizer.
            </p>
            <p>
                Still, much credit to Sean Barrett, the author of the stb libraries. His
                <a href="https://nothings.org/gamedev/rasterize/">writeup on how the stb_truetype
                anti-aliasing works</a> is the reason I was able to understand the rasterization
                process well enough to write it myself.
            </p>
            <p>
                The other most interesting part of the project is the AI. As a challenge to myself,
                I did not read up on how to write a chess bot. I wanted to see how far I could get
                "on my own steam." I'm reasonably happy with the result. It's better than I am at
                chess, though I can still eke out a win against it occasionally.
            </p>
            <p>
                Now that I've made the AI about as good as I can on my own, I'm looking forward to
                finally reading up on the state-of-the-art techniques and implementing some of those
                to see if I can write an AI that I will never checkmate.
            </p>
            <p>
                During this time I also pursued some education unrelated to programming. I
                self-studied math. I read and did odd-numbered exercises in <em>Mathematical Proofs:
                A Transition to Advanced Mathematics</em> by Gary Chartrand, Albert D. Polimeni, and
                Ping Zhang. I'm currently working through <em>Linear Algebra Done Right</em> by
                Sheldon Axler. If it interests you, check out my
                <a href="/jk_assets/website/jkellick_ladr_exercises.pdf">exercise solutions</a> for
                the first three chapters. I also put ~400 hours into learning Chinese.
            </p>
            <p>
                Whew, that's enough talking about myself. That catches us up to the present (as of
                2025-09-26). Thanks for reading! If you're interested in hiring me, or if you'd like
                to contact me for any other reason, email jeremiah@jeremiahkellick.com
            </p>
            <h2>Footnotes</h2>
            <ol>
                <li>
                    <a id="footnote-1" href="#footnote-1-link">↑</a>
                    A <a href="https://youtu.be/x2EOOJg8FkA">case has been made</a> that performance
                    improvements affect revenue more than you might expect, but this was my thought
                    at the time.
                </li>
            </ol>
            <script src="/jk_src/chess/chess.js"></script>
        </div>
    </body>
</html>
