<!DOCTYPE html>
<html>
    <head>
        <title>Jeremiah Kellick</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>

@font-face {
    font-family: "Noto Serif";
    src: url("/jk_assets/website/NotoSerif-Regular.ttf") format("truetype");
}

@font-face {
    font-family: "Noto Serif";
    font-style: italic;
    src: url("/jk_assets/website/NotoSerif-Italic.ttf") format("truetype");
}

body {
    background: #162027;
    color: #d0dbe2;
    font-family: "Noto Serif", sans-serif;
    font-size: 22px;
    line-height: 1.8;
    margin: 0;
}

h1 {
    margin: 0;
    font-weight: normal;
}

#tagline {
    margin: 0;
}

p {
    margin: 25px 0 0 0;
}

a {
    color: #7799ff;
    position: relative;
    text-decoration: underline;
    text-decoration-thickness: 1px;
    text-underline-offset: 8px;
    z-index: 10;
}

a:visited {
    color: #b693fb;
}

blockquote {
    border-left: 4px solid #d0dbe2;
    margin: 0;
    padding-left: 40px;
    padding-bottom: 25px;
}

#content {
    margin: 64px auto;
    padding: 0 32px;
    max-width: 750px;
    overflow-x: hidden;
}

#profile-picture {
    display: block;
    border-radius: 100%;
    margin: auto;
    width: 220px;
}

@media (min-width: 730px) {
    #profile-picture {
        float: left;
        margin: 28px 28px 28px 0;
    }
}

#chess {
    aspect-ratio: 1;
    box-sizing: context-box;
    display: block;
    margin: 25px -12.5% 0 -12.5%;
    width: 125%;
}

        </style>
    </head>
    <body>
        <div id="content">
            <img id="profile-picture" src="/jk_assets/website/profile-picture.jpg" />
            <h1>Hi! I'm Jeremiah</h1>
            <p id="tagline">a web developer turned systems programmer</p>
            <p>
                I'm looking for work. In a hurry? See <a href="/TODO/RESUME">my&nbsp;resume.</a>
                Want my full story? Read on.
            </p>
            <p>
                Google hired me when I was nineteen. I got into programming early because I loved
                video games and wanted to make them. It so captivated me that by my high-school
                graduation, I wanted to do it full-time. So instead of college, I took a chance on a
                faster path. I attended a coding bootcamp called App Academy. They filled gaps in my
                knowledge and prepared me for technical interviews. Then came months of job
                searching. I won't forget the tension answering the recruiter's phone call after my
                Google interviews. To my delight, they made an offer.
            </p>
            <p>
                For the next four years, I worked at Google Pittsburgh making UIs for Vertex AI
                products. I had fun, met incredible people, and learned to work within and across
                teams. It was my dream job. But eventually, I would dream bigger.
            </p>
            <p>
                Before, I didn't see much point in low-level systems knowledge except for
                curiosity's sake. I thought myself pragmatic—I'll take the shortest path to my goal.
                I thought myself humble—the authors of popular libraries and frameworks are better
                than me. If I can get better results faster using code I don't fully understand, I'd
                be foolish not to. Now I realize, that's an awfully big <em>if.</em>
            </p>
            <p>
                One day I saw a talk on YouTube,
                <a href="https://www.youtube.com/watch?v=De0Am_QcZiQ">"Making Game Programming Less
                Terrible"</a> by Jonathan Blow. He criticized Photoshop's "New Document" menu taking
                one second to load. Was this really noteworthy? I encountered larger delays all the
                time, many in the product I worked on.
            </p>
            <p>
                "Imagine if the people who programmed this were trying to make VR games. Like,
                everybody would be vomiting everywhere all the time." Jon Blow joked. His computer
                could render a pretty 3D environment from two different perspectives in eleven
                milliseconds. Why then did it take a thousand to display that "New Document" menu?
            </p>
            <p>
                I thought "It's market-driven." Programmer time is expensive, and it usually takes
                more to achieve high performance. Is the extra cost worth it? You would refund a VR
                game that made you vomit, but few Photoshop subscribers will cancel when the "New
                Document" menu takes a second. Maybe it's just good economics to prioritize other
                things. <a id="footnote-1-link" href="#footnote-1">[1]</a>
            </p>
            <p>
                My opinion changed when Jon compiled his game in under a second. This was already
                impressive at the time, but it gets more so if we jump forward to May 2025 when his
                game was 300k lines of code and <a href="https://youtu.be/RIYGaSBKy3w?t=646">
                compiled in 2.3 seconds.</a> In <a href="https://youtu.be/jamU6SQBtxk?t=5172">an
                interview</a> Jon said, "It's big. So far I think it's a reasonable estimation that
                if the average person wants to 100% the game, it's probably over 500 hours of play
                time."
            </p>
            <p>
                The demonstration threw me. I completely reassessed how we did things at Google. The
                "market-driven" argument doesn't excuse slow compilation. You can't save programmer
                time with shortcuts that bog down compilation. A slow build consumes the resource
                you claimed to be saving. So why did it take 30 minutes to start my project's
                development server? Why did it take 5 minutes to compile unit tests for a single UI
                component? Jon's game was staggeringly more complex than that UI component. He
                compiled on a single computer. I used a server farm.
            </p>
            <p>
                The talk inspired me to learn systems programming to get control of my software's
                compilation and runtime performance. I read the classic <em>C Programming
                Language</em> by Brian Kernighan and Dennis Ritchie. I took some courses from
                Carnegie Mellon as a non-degree student:
            </p>
            <ul>
                <li>18-213 Introduction to Computer Systems</li>
                <li>15-411 Compiler Design</li>
            </ul>
            <p>
                Compiler Design was difficult to balance with my job. I had no time for friends and
                family. After it finished, I left my job at Google to focus full-time on education.
                I took a third course from Carnegie:
            </p>
            <ul>
                <li>15-410 Operating System Design and Implementation</li>
            </ul>
            <p>
                Large programming projects were 90%+ of the workload for those courses. I can't post
                the code publicly, but I can share it privately.
            </p>
            <p>
                Then I took Casey Muratori's Substack course,
                <a href="https://www.computerenhance.com/p/table-of-contents">Performance-Aware
                Programming.</a> It's ongoing, but I watched and did
                <a href="https://github.com/jeremiahkellick/jk_repo/tree/master/jk_src/perfaware">
                the homework</a> for all episodes released at time of writing (2025-09-28).
            </p>
            <p>
                Casey's an endearing teacher. His passion for the subject bleeds through as he
                patiently explains things step by step. His knowledge was earned from a career of
                curiosity and preference for writing things from scratch, rarely depending on
                someone else's code. He has his students learn in the same way. You don't just learn
                to read assembly. You write
                <a href="https://github.com/jeremiahkellick/jk_repo/blob/v0.1/jk_src/perfaware/part1/sim86.c#L945">
                an 8086 simulator.</a> You don't just learn to use a profiler. You write
                <a href="https://github.com/jeremiahkellick/jk_repo/blob/v0.1/jk_src/jk_lib/platform/platform.c#L548">
                your own.</a> It's impossible to do the coursework and not come away with a deep
                understanding of the subject matter.
            </p>
            <p>
                Next, I wanted a project to show publicly that demonstrates systems programming
                knowledge, so I wrote a chess application from scratch in C. It supports three
                platforms: Windows, macOS, and the web. Try the web version below or download native
                executables on the <a href="https://github.com/jeremiahkellick/jk_repo/releases">
                GitHub Releases</a> page. I'll discuss technical details below. But first, try it
                out!
            </p>
            <canvas id="chess"></canvas>
            <p>
                Okay, I hope you think that's neat. I had fun making it! Now let's go behind the
                scenes.
            </p>
            <p>
                At runtime, the Windows and macOS ports depend on only the C standard library and
                APIs provided by their respective operating systems. The web version doesn't even
                depend on a C standard library implementation, so none of the platform-independent
                code can use it either. This took me down some fun rabbit holes.
            </p>
            <p>
                For floating-point rounding and square root, I used x86 intrinsics when compiling
                with MSVC and builtins when using Clang or GCC. There weren't such intrinsics,
                however, for sine and arccosine. Instead, I used Mathematica to compute constants
                for <a href="https://github.com/jeremiahkellick/jk_repo/blob/v0.1/jk_src/jk_lib/jk_lib.c#L544">
                polynomial approximations.</a>
            </p>
            <p>
                I also wrote a printf replacement. The most interesting part was the
                <a href="https://github.com/jeremiahkellick/jk_repo/blob/v0.1/jk_src/jk_lib/jk_lib.c#L326">
                function that converts a floating-point number to a string,</a> accurate to about
                eight decimal places.
            </p>
            <p>
                The app is resolution-independent. I wrote a
                <a href="https://github.com/jeremiahkellick/jk_repo/blob/v0.1/jk_src/jk_shapes/jk_shapes.c#L514">
                vector graphics rasterizer</a> to draw the chess pieces and text. For the chess
                pieces, I
                <a href="https://github.com/jeremiahkellick/jk_repo/blob/v0.1/jk_src/chess/chess_assets_pack.c#L73">
                parse</a> a
                <a href="https://github.com/jeremiahkellick/jk_repo/blob/v0.1/jk_assets/chess/paths.txt">
                subset of the SVG path format.</a> For the text, I use stb_truetype to to extract
                data from a font file and convert it to the format my rasterizer understands, but I
                do that in a separate program that runs as a build step. The executable does not
                contain any stb_truetype code.
            </p>
            <p>
                Still, much credit to Sean Barrett, the author of the stb libraries. His
                <a href="https://nothings.org/gamedev/rasterize/">writeup on the stb_truetype
                anti-aliasing algorithm</a> taught me enough about vector graphics rasterization to
                write it myself.
            </p>
            <p>
                The next most interesting part of the project was the AI. As a challenge to myself,
                I did not read up on how to write a chess bot. I wanted to see how far I would get
                "on my own steam." I'm reasonably happy with the result. It's better than I am at
                chess, though I can still eke out a win against it occasionally.
            </p>
            <p>
                Still, now that I've made the AI about as good as I can on my own, I'm looking
                forward to reading up on state-of-the-art techniques and implementing some to see if
                I can't write an AI that I will never checkmate.
            </p>
            <p>
                During this time I also learned things unrelated to programming. I self-studied
                math. I read and did odd-numbered exercises in <em>Mathematical Proofs: A Transition
                to Advanced Mathematics</em> by Gary Chartrand, Albert D. Polimeni, and Ping Zhang.
                I'm currently working through <em>Linear Algebra Done Right</em> by Sheldon Axler.
                If it interests you, check out my
                <a href="/jk_assets/website/jkellick_ladr_exercises.pdf">exercise solutions</a> for
                the first three chapters. I also spent ~400 hours learning Chinese.
            </p>
            <p>
                That catches us up to the present (as of 2025-09-28). This educational deep dive was
                fun and satisfying. It's neat to look back and see how far I've come. Not long ago I
                was writing code with only the vaguest of notions of how the computer ran it. I
                didn't even have a model of how my data was laid out in memory. Now I've written a
                compiler to turn high level code into assembly, custom memory allocators, and
                operating system code to manage virtual memory.
            </p>
            <p>
                Whew, that's enough talking about myself. If you read all that, I'm pleasantly
                surprised. Thanks for your interest! If you'd like to contact me for any reason (but
                especially if you'd like to hire me), email jeremiah@jeremiahkellick.com
            </p>
            <h2>Footnotes</h2>
            <ol>
                <li>
                    <a id="footnote-1" href="#footnote-1-link">↑</a>
                    A <a href="https://www.computerenhance.com/p/performance-excuses-debunked">case
                    has been made</a> that performance improvements affect revenue more than you
                    might expect, but this was my thought at the time.
                </li>
            </ol>
            <script src="/jk_src/chess/chess.js"></script>
        </div>
    </body>
</html>
